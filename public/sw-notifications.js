/**
 * Service Worker para Notifica√ß√µes Push - Purify App
 * Gerencia notifica√ß√µes em background mesmo com app fechado
 */

const CACHE_NAME = 'purify-notifications-v1'
const NOTIFICATION_TAG = 'purify-daily'

// Notifica√ß√µes motivacionais di√°rias
const DAILY_NOTIFICATIONS = [
  {
    id: 'morning',
    title: 'üåÖ Bom dia, Guerreiro!',
    body: 'Mais um dia para fortalecer sua jornada. Voc√™ consegue!',
    icon: '/192.png',
    badge: '/72.png',
    tag: 'purify-morning',
    data: { type: 'daily', time: 'morning' },
    actions: [
      { action: 'open', title: '‚ú® Abrir App' },
      { action: 'motivate', title: 'üí™ Ver Motiva√ß√£o' }
    ]
  },
  {
    id: 'afternoon',
    title: '‚òÄÔ∏è For√ßa na Caminhada!',
    body: 'Como est√° sua tarde? Lembre-se: cada momento resistindo √© uma vit√≥ria.',
    icon: '/192.png',
    badge: '/72.png',
    tag: 'purify-afternoon',
    data: { type: 'daily', time: 'afternoon' },
    actions: [
      { action: 'open', title: 'üìä Ver Progresso' },
      { action: 'sos', title: 'üö® Preciso de Ajuda' }
    ]
  },
  {
    id: 'evening',
    title: 'üåÜ Reta Final do Dia!',
    body: 'Voc√™ est√° quase completando mais um dia limpo. Continue firme!',
    icon: '/192.png',
    badge: '/72.png',
    tag: 'purify-evening',
    data: { type: 'daily', time: 'evening' },
    actions: [
      { action: 'open', title: 'üèÜ Ver Conquistas' },
      { action: 'reflect', title: 'üôè Reflex√£o' }
    ]
  },
  {
    id: 'night',
    title: 'üåô Boa Noite, Vencedor!',
    body: 'Mais um dia de vit√≥ria! Descanse em paz sabendo que voc√™ venceu hoje.',
    icon: '/192.png',
    badge: '/72.png',
    tag: 'purify-night',
    data: { type: 'daily', time: 'night' },
    actions: [
      { action: 'open', title: '‚ú® Celebrar' },
      { action: 'gratitude', title: 'üôè Gratid√£o' }
    ]
  }
]

// Mensagens para marcos di√°rios
const MILESTONE_MESSAGES = [
  {
    days: 1,
    title: 'üéâ Primeiro Dia Completo!',
    body: 'Parab√©ns! Voc√™ completou seu primeiro dia limpo. O come√ßo √© sempre o mais dif√≠cil!'
  },
  {
    days: 3,
    title: 'üî• 3 Dias Conquistados!',
    body: 'Incr√≠vel! Tr√™s dias seguidos. Sua for√ßa de vontade est√° crescendo!'
  },
  {
    days: 7,
    title: 'üëë Uma Semana de Vit√≥rias!',
    body: 'WOW! Uma semana inteira! Voc√™ provou que consegue. Continue assim!'
  },
  {
    days: 14,
    title: 'üíé Duas Semanas Limpas!',
    body: 'Fant√°stico! 14 dias de transforma√ß√£o. Voc√™ est√° mudando sua vida!'
  },
  {
    days: 30,
    title: 'üöÄ UM M√äS DE SUPERA√á√ÉO!',
    body: 'INCR√çVEL! 30 dias limpos! Voc√™ j√° n√£o √© mais a mesma pessoa. Que orgulho!'
  },
  {
    days: 60,
    title: 'üèÜ 2 MESES DE PUREZA!',
    body: 'EXTRAORDIN√ÅRIO! 60 dias! Voc√™ est√° no caminho da transforma√ß√£o total!'
  },
  {
    days: 90,
    title: 'üåü 3 MESES DE NOVA VIDA!',
    body: 'FENOMENAL! 90 dias! Voc√™ reconstruiu completamente seus h√°bitos!'
  }
]

// Instalar Service Worker
self.addEventListener('install', (event) => {
  console.log('üîî Service Worker de Notifica√ß√µes instalado')
  self.skipWaiting()
})

// Ativar Service Worker
self.addEventListener('activate', (event) => {
  console.log('üîî Service Worker de Notifica√ß√µes ativado')
  event.waitUntil(self.clients.claim())
})

// Listener para mensagens do app principal
self.addEventListener('message', (event) => {
  const { type, data } = event.data

  switch (type) {
    case 'SCHEDULE_DAILY_NOTIFICATIONS':
      scheduleDailyNotifications(data.times)
      break
    case 'SCHEDULE_MILESTONE_NOTIFICATION':
      scheduleMilestoneNotification(data.days)
      break
    case 'CANCEL_ALL_NOTIFICATIONS':
      cancelAllNotifications()
      break
    case 'GET_SCHEDULED_NOTIFICATIONS':
      getScheduledNotifications().then(notifications => {
        event.ports[0].postMessage({ notifications })
      })
      break
  }
})

// Fun√ß√£o para agendar notifica√ß√µes di√°rias
async function scheduleDailyNotifications(times) {
  try {
    // Cancelar notifica√ß√µes anteriores
    const existingNotifications = await self.registration.getNotifications()
    existingNotifications.forEach(notification => {
      if (notification.tag.startsWith('purify-')) {
        notification.close()
      }
    })

    const now = new Date()
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())

    DAILY_NOTIFICATIONS.forEach((notification, index) => {
      const timeKey = notification.id // 'morning', 'afternoon', etc.
      const timeConfig = times[timeKey]
      
      if (timeConfig && timeConfig.enabled) {
        const [hours, minutes] = timeConfig.time.split(':').map(Number)
        const notificationTime = new Date(today)
        notificationTime.setHours(hours, minutes, 0, 0)

        // Se o hor√°rio j√° passou hoje, agendar para amanh√£
        if (notificationTime <= now) {
          notificationTime.setDate(notificationTime.getDate() + 1)
        }

        const delay = notificationTime.getTime() - now.getTime()

        setTimeout(() => {
          self.registration.showNotification(notification.title, {
            body: notification.body,
            icon: notification.icon,
            badge: notification.badge,
            tag: notification.tag,
            data: notification.data,
            actions: notification.actions,
            requireInteraction: false,
            silent: false,
            vibrate: [200, 100, 200]
          })

          // Reagendar para o pr√≥ximo dia
          setInterval(() => {
            if (isNotificationTimeEnabled(timeKey)) {
              self.registration.showNotification(notification.title, {
                body: notification.body,
                icon: notification.icon,
                badge: notification.badge,
                tag: notification.tag,
                data: notification.data,
                actions: notification.actions,
                requireInteraction: false,
                silent: false,
                vibrate: [200, 100, 200]
              })
            }
          }, 24 * 60 * 60 * 1000) // 24 horas
        }, delay)
      }
    })

    console.log('üìÖ Notifica√ß√µes di√°rias agendadas:', times)
  } catch (error) {
    console.error('‚ùå Erro ao agendar notifica√ß√µes di√°rias:', error)
  }
}

// Fun√ß√£o para agendar notifica√ß√£o de marco
function scheduleMilestoneNotification(currentDays) {
  const milestone = MILESTONE_MESSAGES.find(m => m.days === currentDays + 1)
  
  if (milestone) {
    // Agendar para 00:01 do pr√≥ximo dia
    const now = new Date()
    const tomorrow = new Date(now)
    tomorrow.setDate(tomorrow.getDate() + 1)
    tomorrow.setHours(0, 1, 0, 0) // 00:01

    const delay = tomorrow.getTime() - now.getTime()

    setTimeout(() => {
      self.registration.showNotification(milestone.title, {
        body: milestone.body,
        icon: '/192.png',
        badge: '/72.png',
        tag: `purify-milestone-${milestone.days}`,
        data: { type: 'milestone', days: milestone.days },
        actions: [
          { action: 'celebrate', title: 'üéâ Celebrar' },
          { action: 'share', title: 'üì± Compartilhar' }
        ],
        requireInteraction: true,
        silent: false,
        vibrate: [300, 100, 300, 100, 300]
      })
    }, delay)

    console.log(`üéØ Notifica√ß√£o de marco agendada para ${milestone.days} dias`)
  }
}

// Verificar se hor√°rio est√° habilitado (buscar do localStorage via mensagem)
function isNotificationTimeEnabled(timeKey) {
  // Esta fun√ß√£o ser√° melhorada para verificar configura√ß√µes em tempo real
  return true // Por enquanto, assume que est√° habilitado
}

// Cancelar todas as notifica√ß√µes
async function cancelAllNotifications() {
  try {
    const notifications = await self.registration.getNotifications()
    notifications.forEach(notification => notification.close())
    console.log('üö´ Todas as notifica√ß√µes canceladas')
  } catch (error) {
    console.error('‚ùå Erro ao cancelar notifica√ß√µes:', error)
  }
}

// Obter notifica√ß√µes agendadas
async function getScheduledNotifications() {
  try {
    const notifications = await self.registration.getNotifications()
    return notifications.map(n => ({
      title: n.title,
      body: n.body,
      tag: n.tag,
      data: n.data
    }))
  } catch (error) {
    console.error('‚ùå Erro ao obter notifica√ß√µes:', error)
    return []
  }
}

// Listener para clique em notifica√ß√µes
self.addEventListener('notificationclick', (event) => {
  const notification = event.notification
  const action = event.action
  const data = notification.data

  console.log('üîî Notifica√ß√£o clicada:', { action, data })

  notification.close()

  // Determinar URL baseada na a√ß√£o
  let targetUrl = '/'
  
  switch (action) {
    case 'motivate':
      targetUrl = '/motivacao'
      break
    case 'sos':
      targetUrl = '/emergencia'
      break
    case 'open':
      targetUrl = '/'
      break
    case 'reflect':
      targetUrl = '/bem-estar'
      break
    case 'celebrate':
    case 'share':
      targetUrl = '/estatistica'
      break
    default:
      if (data?.type === 'milestone') {
        targetUrl = '/gamificacao'
      } else {
        targetUrl = '/'
      }
  }

  // Abrir ou focar no app
  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clients) => {
      // Verificar se j√° existe uma janela aberta
      for (const client of clients) {
        if (client.url.includes(self.location.origin)) {
          client.navigate(targetUrl)
          return client.focus()
        }
      }
      
      // Se n√£o existe, abrir nova janela
      return self.clients.openWindow(targetUrl)
    })
  )

  // Enviar evento para analytics (opcional)
  if (data?.type) {
    self.clients.matchAll().then(clients => {
      clients.forEach(client => {
        client.postMessage({
          type: 'NOTIFICATION_CLICKED',
          data: { notificationType: data.type, action }
        })
      })
    })
  }
})

// Listener para fechar notifica√ß√£o
self.addEventListener('notificationclose', (event) => {
  console.log('üîî Notifica√ß√£o fechada:', event.notification.tag)
})

console.log('üîî Service Worker de Notifica√ß√µes carregado')
